import pandas as pd
import argparse
import html
import os
import sqlite3
import subprocess
import sys
from datetime import date, timedelta, datetime
import plotly.graph_objects as go
import plotly.express as px
import networkx as nx
import json
from urllib.parse import urlparse

# Security Note: The HTML is generated by embedding data directly. 
# While the data (URLs, paths, statuses) is generally from crawling trusted sites or self-generated,
# for broader applications, using a templating engine (like Jinja2) would be a safer practice 
# to prevent potential XSS if data sources were less controlled.

def generate_html_table_from_df(df, table_id):
    """Generates an HTML table string from a pandas DataFrame for use with DataTables."""
    if df.empty:
        return f"<p>No data available for {table_id.replace('Table', '')}.</p>"

    table_html = f'''
    <table id="{table_id}" class="display" style="width:100%">
        <thead>
            <tr>{''.join(f'<th>{col}</th>' for col in df.columns)}</tr>
            <tr class="filters">{''.join("<th><input type='text' placeholder='Filter ...' style='width: 90%;' /></th>" for _ in df.columns)}</tr>
        </thead>
        <tbody>
'''
    for _, row in df.iterrows():
        status_val = row.get("Status", "N/A") # Get status, default to N/A if not present
        try:
            status = int(float(status_val)) if pd.notna(status_val) else 0
        except ValueError:
            status = 0 # Default for non-integer statuses

        cls = "ok" if status == 200 else "redirect" if 300 <= status < 400 else "error"
        table_html += f"<tr class='{cls}'>"
        for col, val in row.items():
            # Ensure HTML special characters in data are escaped to prevent XSS. Pandas to_html does this by default.
            # Here, we are manually creating cells, so care is needed. For URLs, it's common to allow them as hrefs.
            # For other text, escaping would be important if it could come from untrusted input.
            # Given the source of this data, direct embedding is lower risk but not best practice.
            escaped_val = html.escape(str(val))
            if col == "URL":
                table_html += f"<td><a href='{escaped_val}' target='_blank'>{escaped_val}</a></td>"
            else:
                table_html += f"<td>{escaped_val}</td>"
        table_html += "</tr>"
    table_html += """
        </tbody>
    </table>
"""
    return table_html

STYLE_DEFINITIONS = """
            :root {
                --container-max: 1400px;
                --brand: #0d6efd;
                --muted-bg: #f6f7f9;
                --muted: #6c757d;
                --card-bg: #ffffff;
                --border: #e5e7eb;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                margin: 0;
                background-color: var(--muted-bg);
                color: #1f2937;
            }
            header {
                background: linear-gradient(180deg, #fff, #fafbfc);
                border-bottom: 1px solid var(--border);
                padding: 24px 16px 16px;
                margin-bottom: 16px;
            }
            h1 {
                text-align: center;
                margin: 0 auto;
                max-width: var(--container-max);
                font-weight: 700;
                letter-spacing: .2px;
            }
            .container {
                max-width: var(--container-max);
                margin: 0 auto;
                padding: 0 16px 24px;
            }
            .summary-container {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                margin-bottom: 16px;
            }
            .summary-item {
                background-color: #eef2f7;
                padding: 10px 14px;
                border-radius: 999px;
                font-size: 14px;
                border: 1px solid var(--border);
            }
            .tab-container {
                margin-top: 12px;
                background-color: var(--card-bg);
                padding: 0 0 16px;
                border-radius: 12px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.06);
                border: 1px solid var(--border);
            }
            .tab-buttons {
                display: flex;
                gap: 12px;
                padding: 12px;
                border-bottom: 1px solid var(--border);
                background: #fff;
                position: sticky;
                top: 0;
                z-index: 10;
            }
            .tab-link {
                background-color: #f3f4f6;
                border: 1px solid var(--border);
                padding: 12px 24px;
                cursor: pointer;
                border-radius: 10px;
                font-weight: 700;
                font-size: 15px;
                letter-spacing: .2px;
                min-width: 160px;
                transition: all .15s ease;
            }
            .tab-link.active, .tab-link:hover {
                background-color: #e9effe;
                border-color: #c2d3ff;
                color: #0b3fbf;
            }
            .tab-content {
                display: none;
                padding: 16px;
            }
            .card {
                background: #fff;
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 14px;
                box-shadow: 0 2px 10px rgba(0,0,0,.04);
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                background: #fff;
                border-radius: 8px;
                overflow: hidden;
            }
            th, td {
                text-align: left;
                padding: 10px 12px;
                border-bottom: 1px solid #eee;
            }
            th {
                background-color: #f8fafc;
                color: #111827;
            }
            .download-button {
                display: inline-block;
                margin: 10px 0;
                padding: 10px 15px;
                background-color: var(--brand);
                color: white;
                text-decoration: none;
                border-radius: 6px;
            }
            .download-button:hover { filter: brightness(.95); }
            #scrollTopBtn, #scrollBottomBtn {
                position: fixed;
                right: 20px;
                padding: 10px;
                font-size: 18px;
                border: none;
                border-radius: 8px;
                background-color: var(--brand);
                color: white;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            }
            #scrollTopBtn { bottom: 80px; }
            #scrollBottomBtn { bottom: 24px; }
            .download-tab-button {
                display: inline-block;
                padding: 8px 12px;
                background-color: #6c757d;
                color: white;
                text-decoration: none;
                border-radius: 999px;
                margin-left: 10px;
                font-size: 12px;
                border: 1px solid var(--border);
            }
            .download-tab-button:hover { filter: brightness(.95); }
            .collapsible-section {
                margin: 20px 0;
                border: 1px solid var(--border);
                border-radius: 10px;
                overflow: hidden;
            }
            .collapsible-header {
                background: linear-gradient(135deg, #f8fafc, #e2e8f0);
                padding: 16px 20px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
                border-bottom: 1px solid var(--border);
            }
            .collapsible-header:hover {
                background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
            }
            .collapsible-header.active {
                background: linear-gradient(135deg, #dbeafe, #bfdbfe);
                color: #1e40af;
            }
            .collapsible-content {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
                background: #fff;
            }
            .collapsible-content.active {
                max-height: none;
                padding: 20px;
            }
            /* New styles for changes tables */
            .changes-table-added tbody tr {
                background-color: #f0fdf4 !important;
                border-left: 4px solid #22c55e;
            }
            .changes-table-added tbody tr:hover {
                background-color: #dcfce7 !important;
            }
            .changes-table-removed tbody tr {
                background-color: #fef2f2 !important;
                border-left: 4px solid #ef4444;
            }
            .changes-table-removed tbody tr:hover {
                background-color: #fecaca !important;
            }
            .change-type-badge {
                display: inline-block;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 12px;
                font-weight: 600;
                text-transform: uppercase;
            }
            .change-type-badge.added {
                background-color: #dcfce7;
                color: #166534;
                border: 1px solid #86efac;
            }
            .change-type-badge.removed {
                background-color: #fef2f2;
                color: #991b1b;
                border: 1px solid #fca5a5;
            }
            .toggle-icon {
                font-size: 18px;
                transition: transform 0.3s ease;
            }
            .toggle-icon.rotated {
                transform: rotate(180deg);
            }
            .changes-summary {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
                flex-wrap: wrap;
            }
            .change-count {
                padding: 12px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 14px;
                min-width: 120px;
                text-align: center;
            }
            .change-count.added {
                background: linear-gradient(135deg, #dcfce7, #bbf7d0);
                color: #166534;
                border: 1px solid #86efac;
            }
            .change-count.removed {
                background: linear-gradient(135deg, #fef2f2, #fecaca);
                color: #991b1b;
                border: 1px solid #fca5a5;
            }
            .visualization-container {
                background: #fff;
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 20px;
                margin: 16px 0;
                box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            }
            .category-tabs {
                display: flex;
                gap: 8px;
                margin-bottom: 20px;
                border-bottom: 2px solid var(--border);
            }
            .category-tab {
                padding: 12px 24px;
                background: #f8fafc;
                border: 1px solid var(--border);
                border-bottom: none;
                border-radius: 8px 8px 0 0;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.2s ease;
            }
            .category-tab.active {
                background: #fff;
                border-bottom: 2px solid #fff;
                margin-bottom: -2px;
                color: var(--brand);
            }
            .category-content {
                display: none;
            }
            .category-content.active {
                display: block;
            }

            /* Product Availability Styles */
            .product-availability-container {
                margin-top: 20px;
            }
            /* Table container for responsive design */
            .table-container {
                width: 100%;
                overflow-x: auto;
                margin-top: 15px;
            }

            .product-table {
                width: 100%;
                min-width: 600px;
                border-collapse: collapse;
                background-color: white;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .product-table th {
                background-color: var(--brand);
                color: white;
                padding: 12px;
                text-align: left;
                font-weight: 600;
                font-size: 14px;
                white-space: nowrap;
            }
            .product-table td {
                padding: 12px;
                border-bottom: 1px solid #e5e7eb;
                vertical-align: top;
                word-wrap: break-word;
                max-width: 300px;
            }
            .product-row {
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            .product-row:hover {
                background-color: #f9fafb;
            }
            .product-details-row {
                background-color: #f8fafc;
            }
            .product-details-content {
                padding: 16px;
                border-left: 4px solid var(--brand);
                background-color: #fff;
                border-radius: 8px;
                margin: 8px;
            }
            .product-details-content h4 {
                margin: 0 0 12px 0;
                color: var(--brand);
                font-size: 16px;
            }
            .json-display {
                background-color: #f8fafc;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                padding: 12px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 12px;
                line-height: 1.4;
                overflow-x: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
                max-height: 400px;
                overflow-y: auto;
            }

            /* Product Attribute Styles */
            .attributes-section {
                margin-bottom: 20px;
            }
            .attributes-container {
                background-color: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 16px;
                max-height: 400px;
                overflow-y: auto;
            }
            .attribute-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                margin-bottom: 4px;
                background-color: #ffffff;
                border: 1px solid #e9ecef;
                border-radius: 4px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            }
            .attribute-item:last-child {
                margin-bottom: 0;
            }
            .attr-name {
                color: #495057;
                min-width: 180px;
                flex-shrink: 0;
                margin-right: 12px;
            }
            .attr-value {
                color: #6c757d;
                text-align: right;
                word-break: break-word;
                flex-grow: 1;
            }
            .no-attributes {
                text-align: center;
                color: #6c757d;
                font-style: italic;
                padding: 20px;
            }

            /* Visual Indicators */
            .past-date {
                background-color: #fee2e2 !important;
                border-left: 4px solid #dc2626 !important;
                padding-left: 8px !important;
            }
            .past-date .attribute-value {
                color: #dc2626 !important;
                font-weight: 600 !important;
            }
            .discontinued-indicator {
                background-color: #dc2626;
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: 600;
                text-align: center;
                margin-bottom: 12px;
                font-size: 14px;
            }
            .product-type-badge.discontinued {
                background-color: #dc2626 !important;
                color: white !important;
                font-weight: 600 !important;
            }
            .product-type-badge {
                display: inline-block;
                padding: 4px 8px;
                background-color: #e0f2fe;
                color: #0369a1;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                margin-left: 8px;
            }
            .toggle-icon {
                font-size: 14px;
                margin-right: 8px;
                transition: transform 0.3s ease;
                display: inline-block;
            }
            .toggle-icon.rotated {
                transform: rotate(180deg);
            }
"""

def extract_category_hierarchy(df, region):
    """Extract hierarchical category data from URLs and store in temporary file."""
    if df.empty:
        return {}
    
    category_hierarchy = {}
    
    for _, row in df.iterrows():
        try:
            url = row['URL']
            parsed = urlparse(url)
            path = parsed.path.strip('/')
            
            if path:
                segments = path.split('/')
                # Look for category patterns
                for i, segment in enumerate(segments):
                    if 'category' in segment.lower() or 'categories' in segment.lower():
                        # This is a category segment
                        if i + 1 < len(segments):
                            category_name = segments[i + 1].replace('-', ' ').replace('_', ' ').title()
                            
                            if category_name not in category_hierarchy:
                                category_hierarchy[category_name] = {
                                    'count': 0,
                                    'subcategories': set(),
                                    'urls': []
                                }
                            
                            category_hierarchy[category_name]['count'] += 1
                            category_hierarchy[category_name]['urls'].append(url)
                            
                            # Check for subcategories
                            if i + 2 < len(segments):
                                subcategory = segments[i + 2].replace('-', ' ').replace('_', ' ').title()
                                category_hierarchy[category_name]['subcategories'].add(subcategory)
                    
                    # Also check for direct category names in path
                    elif segment.lower() in ['home', 'clothing', 'electronics', 'toys', 'beauty', 'garden', 'sports', 'outdoor', 'tech', 'baby', 'kids']:
                        category_name = segment.replace('-', ' ').replace('_', ' ').title()
                        
                        if category_name not in category_hierarchy:
                            category_hierarchy[category_name] = {
                                'count': 0,
                                'subcategories': set(),
                                'urls': []
                            }
                        
                        category_hierarchy[category_name]['count'] += 1
                        category_hierarchy[category_name]['urls'].append(url)
                        
                        # Check for subcategories
                        if i + 1 < len(segments):
                            subcategory = segments[i + 1].replace('-', ' ').replace('_', ' ').title()
                            category_hierarchy[category_name]['subcategories'].add(subcategory)
        except Exception:
            continue
    
    # Convert sets to lists for JSON serialization
    for category in category_hierarchy:
        category_hierarchy[category]['subcategories'] = list(category_hierarchy[category]['subcategories'])
    
    # Return category hierarchy directly without saving to temp file
    return category_hierarchy

def generate_site_architecture_visualization(df, region):
    """Generate interactive site architecture visualization using Plotly and NetworkX."""
    if df.empty:
        return "<p>No data available for visualization.</p>"
    
    # Extract domain and path information
    urls = df['URL'].dropna().tolist()
    
    # Create a network graph
    G = nx.DiGraph()
    
    # Parse URLs and create hierarchical structure
    domain_paths = {}
    for url in urls:
        try:
            parsed = urlparse(url)
            domain = parsed.netloc
            path = parsed.path.strip('/')
            
            if domain not in domain_paths:
                domain_paths[domain] = set()
            
            # Split path into segments
            if path:
                segments = path.split('/')
                # Add hierarchical relationships
                current_path = ''
                for i, segment in enumerate(segments):
                    parent_path = current_path
                    current_path = '/'.join(segments[:i+1]) if current_path else segment
                    
                    if parent_path:
                        G.add_edge(f"{domain}/{parent_path}", f"{domain}/{current_path}")
                    else:
                        G.add_edge(domain, f"{domain}/{current_path}")
                    
                    domain_paths[domain].add(current_path)
            else:
                G.add_node(domain)
        except Exception:
            continue
    
    if not G.nodes():
        return "<p>No valid URLs found for visualization.</p>"
    
    # Create layout
    try:
        pos = nx.spring_layout(G, k=3, iterations=50)
    except:
        pos = {node: (0, 0) for node in G.nodes()}
    
    # Extract node and edge information
    node_x = []
    node_y = []
    node_text = []
    node_colors = []
    
    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        node_text.append(node)
        # Color nodes based on type (domain vs path)
        if '/' in node and node.count('/') > 1:
            node_colors.append('#ff7f0e')  # Orange for deep paths
        elif '/' in node:
            node_colors.append('#2ca02c')  # Green for first-level paths
        else:
            node_colors.append('#1f77b4')  # Blue for domains
    
    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])
    
    # Create Plotly figure
    fig = go.Figure()
    
    # Add edges
    fig.add_trace(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=1, color='#888'),
        hoverinfo='none',
        mode='lines',
        name='Connections'
    ))
    
    # Add nodes
    fig.add_trace(go.Scatter(
        x=node_x, y=node_y,
        mode='markers+text',
        hoverinfo='text',
        text=node_text,
        textposition="middle center",
        marker=dict(
            size=20,
            color=node_colors,
            line=dict(width=2, color='white')
        ),
        name='Pages'
    ))
    
    fig.update_layout(
        title=dict(text=f'{region} Site Architecture', font=dict(size=16)),
        showlegend=False,
        hovermode='closest',
        margin=dict(b=20,l=5,r=5,t=40),
        annotations=[
            dict(
                text=f"Interactive visualization of {region} site structure",
                showarrow=False,
                xref="paper", yref="paper",
                x=0.005, y=-0.002,
                xanchor="left", yanchor="bottom",
                font=dict(color="#888", size=12)
            )
        ],
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor='white'
    )
    
    return fig.to_html(include_plotlyjs='cdn', div_id=f'{region.lower()}_architecture')

def generate_navigation_hierarchy_chart(df, region):
    """Generate a hierarchical chart showing navigation structure."""
    if df.empty:
        return "<p>No data available for navigation hierarchy.</p>"
    
    # Extract path hierarchy
    path_counts = {}
    for _, row in df.iterrows():
        try:
            url = row['URL']
            parsed = urlparse(url)
            path = parsed.path.strip('/')
            
            if path:
                segments = path.split('/')
                for i, segment in enumerate(segments):
                    level = i + 1
                    if level not in path_counts:
                        path_counts[level] = {}
                    if segment not in path_counts[level]:
                        path_counts[level][segment] = 0
                    path_counts[level][segment] += 1
        except Exception:
            continue
    
    if not path_counts:
        return "<p>No navigation hierarchy found.</p>"
    
    # Create sunburst chart
    labels = []
    parents = []
    values = []
    
    # Add root
    labels.append(f'{region} Root')
    parents.append('')
    values.append(len(df))
    
    # Add hierarchy levels
    for level in sorted(path_counts.keys()):
        for segment, count in path_counts[level].items():
            labels.append(segment)
            if level == 1:
                parents.append(f'{region} Root')
            else:
                parents.append('')  # Simplified for demo
            values.append(count)
    
    fig = go.Figure(go.Sunburst(
        labels=labels,
        parents=parents,
        values=values,
        branchvalues="total",
    ))
    
    fig.update_layout(
        title=f'{region} Navigation Hierarchy',
        font_size=12,
        margin=dict(t=50, l=0, r=0, b=0)
    )
    
    return fig.to_html(include_plotlyjs='cdn', div_id=f'{region.lower()}_hierarchy')

def generate_category_hierarchy_visualization(df, region):
    """Generate scattered category visualization with expandable details."""
    if df.empty:
        return "<p>No data available for category visualization.</p>"
    
    # Extract category hierarchy
    category_data = extract_category_hierarchy(df, region)
    
    if not category_data:
        return "<p>No categories found in the data.</p>"
    
    # Generate HTML for category visualization
    html_content = f"""
    <div class="category-hierarchy-container">
        <h3>{region} Category Hierarchy</h3>
        <div class="categories-grid">
    """
    
    for category, data in category_data.items():
        subcategories_html = ""
        if data['subcategories']:
            subcategories_html = "<ul class='subcategories-list'>" + "".join([
                f"<li>{sub}</li>" for sub in data['subcategories']
            ]) + "</ul>"
        
        html_content += f"""
        <div class="category-card">
            <div class="category-header" onclick="toggleCategoryDetails('{region.lower()}_{category.replace(' ', '_')}')">
                <span class="category-name">{category}</span>
                <span class="category-count">({data['count']} links)</span>
                <span class="expand-icon" id="{region.lower()}_{category.replace(' ', '_')}_icon">â–¼</span>
            </div>
            <div class="category-details" id="{region.lower()}_{category.replace(' ', '_')}_details">
                {subcategories_html if subcategories_html else '<p class="no-subcategories">No subcategories found</p>'}
                <div class="category-urls">
                    <strong>Sample URLs:</strong>
                    <ul>
                        {''.join([f'<li><a href="{url}" target="_blank">{url[:50]}...</a></li>' for url in data['urls'][:3]])}
                    </ul>
                </div>
            </div>
        </div>
        """
    
    html_content += """
        </div>
    </div>
    
    <style>
    .category-hierarchy-container {
        margin: 20px 0;
        padding: 20px;
        background: #f8fafc;
        border-radius: 12px;
        border: 1px solid #e2e8f0;
    }
    
    .categories-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 16px;
        margin-top: 16px;
    }
    
    .category-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        transition: all 0.2s ease;
    }
    
    .category-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-1px);
    }
    
    .category-header {
        padding: 16px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
    }
    
    .category-name {
        font-size: 16px;
        flex-grow: 1;
    }
    
    .category-count {
        background: rgba(255,255,255,0.2);
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        margin: 0 8px;
    }
    
    .expand-icon {
        font-size: 14px;
        transition: transform 0.3s ease;
    }
    
    .expand-icon.rotated {
        transform: rotate(180deg);
    }
    
    .category-details {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        background: white;
    }
    
    .category-details.expanded {
        max-height: 500px;
        padding: 16px;
    }
    
    .subcategories-list {
        margin: 0 0 16px 0;
        padding: 0;
        list-style: none;
    }
    
    .subcategories-list li {
        background: #f1f5f9;
        padding: 8px 12px;
        margin: 4px 0;
        border-radius: 6px;
        border-left: 3px solid #3b82f6;
    }
    
    .no-subcategories {
        color: #64748b;
        font-style: italic;
        margin: 0 0 16px 0;
    }
    
    .category-urls ul {
        margin: 8px 0 0 0;
        padding: 0;
        list-style: none;
    }
    
    .category-urls li {
        margin: 4px 0;
    }
    
    .category-urls a {
        color: #3b82f6;
        text-decoration: none;
        font-size: 12px;
    }
    
    .category-urls a:hover {
        text-decoration: underline;
    }
    </style>
    
    <script>
    function toggleCategoryDetails(categoryId) {
        const details = document.getElementById(categoryId + '_details');
        const icon = document.getElementById(categoryId + '_icon');
        
        if (details.classList.contains('expanded')) {
            details.classList.remove('expanded');
            icon.classList.remove('rotated');
            icon.textContent = 'â–¼';
        } else {
            details.classList.add('expanded');
            icon.classList.add('rotated');
            icon.textContent = 'â–²';
        }
    }
    </script>
    """
    
    return html_content

def _connect_db(db_path: str = 'broken_links.db'):
    conn = sqlite3.connect(db_path)
    return conn

def _create_sample_historical_data(conn: sqlite3.Connection, current_data: pd.DataFrame):
    """Create sample historical data for demonstration purposes if no historical data exists."""
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%'")
    existing_tables = [row[0] for row in cursor.fetchall()]

    # Only create sample data if we have NO historical tables (complete fallback)
    if len(existing_tables) == 0:
        print("Debug: No historical data found, creating minimal sample data for change detection")

        # Create yesterday's data (remove some links, add some different ones)
        yesterday_date = (date.today() - timedelta(days=1)).strftime('%Y_%m_%d')
        yesterday_table = f"broken_links_{yesterday_date}"

        # Create table
        cursor.execute(f"""
            CREATE TABLE IF NOT EXISTS {yesterday_table} (
                Region TEXT,
                URL TEXT,
                Status INTEGER,
                Response_Time REAL,
                Error_Message TEXT,
                Timestamp TEXT
            )
        """)

        # Sample some current data and modify it
        if not current_data.empty:
            # Take 80% of current data as "yesterday's" data
            sample_size = max(1, int(len(current_data) * 0.8))
            yesterday_data = current_data.sample(n=sample_size).copy()

            # Add a few sample "removed" links (links that were broken yesterday but fixed today)
            removed_samples = [
                ('AU', 'https://example-fixed-1.com.au/page', 404, 1.2, 'Not Found', datetime.now().isoformat()),
                ('NZ', 'https://example-fixed-2.co.nz/page', 500, 2.1, 'Internal Server Error', datetime.now().isoformat()),
                ('AU', 'https://example-fixed-3.com.au/product', 403, 0.8, 'Forbidden', datetime.now().isoformat())
            ]

            for region, url, status, resp_time, error, timestamp in removed_samples:
                cursor.execute(f"""
                    INSERT INTO {yesterday_table} (Region, URL, Status, Response_Time, Error_Message, Timestamp)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (region, url, status, resp_time, error, timestamp))

            # Insert the sampled current data as yesterday's data
            for _, row in yesterday_data.iterrows():
                cursor.execute(f"""
                    INSERT INTO {yesterday_table} (Region, URL, Status, Response_Time, Error_Message, Timestamp)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (row['Region'], row['URL'], row['Status'], row.get('Response_Time', 1.0),
                     row.get('Error_Message', 'Error'), row.get('Timestamp', datetime.now().isoformat())))

        conn.commit()
        print(f"Debug: Created sample historical data table {yesterday_table}")
    else:
        print(f"Debug: Found {len(existing_tables)} existing tables, no sample data needed")

def _ensure_retention(conn: sqlite3.Connection, keep_days: int = 60):
    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%';")
    tables = [r[0] for r in cur.fetchall()]
    cutoff = date.today() - timedelta(days=keep_days)
    for t in tables:
        try:
            d_str = t.replace('broken_links_', '')
            d = datetime.strptime(d_str, '%Y_%m_%d').date()
        except Exception:
            continue
        if d < cutoff:
            cur.execute(f'DROP TABLE IF EXISTS {t}')
    conn.commit()

def _store_broken_links_today(conn: sqlite3.Connection, df: pd.DataFrame):
    # df expected columns include Region, URL, Status, Response_Time, Error_Message, Timestamp
    today_str = date.today().strftime('%Y_%m_%d')
    table = f"broken_links_{today_str}"
    cur = conn.cursor()
    cur.execute(f"""
        CREATE TABLE IF NOT EXISTS {table} (
            Region TEXT,
            URL TEXT,
            Status INTEGER,
            Response_Time REAL,
            Error_Message TEXT,
            Timestamp TEXT
        )
    """)
    # Clear existing records for today to prevent duplicates
    cur.execute(f"DELETE FROM {table}")
    # Insert rows
    records = df[df['Status'] >= 400][['Region','URL','Status','Response_Time','Error_Message','Timestamp']].to_records(index=False)
    cur.executemany(
        f"INSERT INTO {table} (Region, URL, Status, Response_Time, Error_Message, Timestamp) VALUES (?,?,?,?,?,?)",
        list(records)
    )
    conn.commit()

def _load_broken_set(conn: sqlite3.Connection, target_date: date) -> set[tuple[str, str]]:
    table = f"broken_links_{target_date.strftime('%Y_%m_%d')}"
    cur = conn.cursor()
    try:
        cur.execute(f"SELECT Region, URL FROM {table}")
    except sqlite3.OperationalError:
        return set()
    return set(cur.fetchall())

def _compute_changes(conn: sqlite3.Connection):
    # Dynamically detect available dates from database tables
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%'")
    tables = [row[0] for row in cursor.fetchall()]
    
    # Extract dates from table names and sort them
    available_dates = []
    for table in tables:
        if table.startswith('broken_links_'):
            date_str = table.replace('broken_links_', '')
            try:
                # Parse date format: YYYY_MM_DD
                year, month, day = map(int, date_str.split('_'))
                available_dates.append(date(year, month, day))
            except ValueError:
                continue
    
    available_dates.sort(reverse=True)  # Most recent first
    
    if len(available_dates) == 0:
        # No data available
        return {
            'yesterday': {'added': [], 'removed': [], 'has_data': False},
            'week': {'added': [], 'removed': [], 'has_data': False},
            'today_count': 0,
            'available_dates': []
        }
    
    # Use the most recent date as "today"
    today_d = available_dates[0]
    
    # Find the closest previous date for "yesterday" comparison
    yday_d = None
    for d in available_dates[1:]:
        if d < today_d:
            yday_d = d
            break
    
    # Find a date approximately 7 days before today for "week" comparison
    week_d = None
    target_week_date = today_d - timedelta(days=7)
    for d in available_dates:
        if d <= target_week_date:
            week_d = d
            break
    
    today_set = _load_broken_set(conn, today_d)
    yday_set = _load_broken_set(conn, yday_d) if yday_d else set()
    week_set = _load_broken_set(conn, week_d) if week_d else set()
    
    # Check if we have data to compare
    has_yesterday_data = len(yday_set) > 0
    has_week_data = len(week_set) > 0
    
    # Added = in today but not in past; Removed = in past but not in today
    if has_yesterday_data:
        y_added = sorted(list(today_set - yday_set))
        y_removed = sorted(list(yday_set - today_set))
    else:
        y_added = []
        y_removed = []
    
    if has_week_data:
        w_added = sorted(list(today_set - week_set))
        w_removed = sorted(list(week_set - today_set))
    else:
        w_added = []
        w_removed = []
    
    return {
        'yesterday': {
            'added': y_added,
            'removed': y_removed,
            'has_data': has_yesterday_data
        },
        'week': {
            'added': w_added,
            'removed': w_removed,
            'has_data': has_week_data
        },
        'today_count': len(today_set),
        'available_dates': available_dates
    }

def generate_combined_html_report(au_csv_path, nz_csv_path, output_html_path='combined_report.html', product_csv_path='product_export.csv', db_path='broken_links.db'):
    """Generates a combined HTML report with tabs for AU and NZ link check results."""
    try:
        au_df = pd.read_csv(au_csv_path, encoding='utf-8', encoding_errors='replace')
        au_df['Status'] = pd.to_numeric(au_df['Status'], errors='coerce').fillna(0).astype(int)
        # Extract category hierarchy for AU
        extract_category_hierarchy(au_df, 'AU')
    except FileNotFoundError:
        print(f"Warning: AU results file not found at {au_csv_path}. AU tab will be empty.")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])
    except Exception as e:
        print(f"Error reading AU CSV {au_csv_path}: {e}")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])

    try:
        nz_df = pd.read_csv(nz_csv_path, encoding='utf-8', encoding_errors='replace')
        nz_df['Status'] = pd.to_numeric(nz_df['Status'], errors='coerce').fillna(0).astype(int)
        # Extract category hierarchy for NZ
        extract_category_hierarchy(nz_df, 'NZ')
    except FileNotFoundError:
        print(f"Warning: NZ results file not found at {nz_csv_path}. NZ tab will be empty.")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])
    except Exception as e:
        print(f"Error reading NZ CSV {nz_csv_path}: {e}")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])

    # Load product data
    try:
        product_df = pd.read_csv(product_csv_path, encoding='utf-8', encoding_errors='replace')
        print(f"âœ… Loaded {len(product_df)} product records from {product_csv_path}")
    except FileNotFoundError:
        print(f"âš ï¸ Product CSV file not found: {product_csv_path}, creating empty dataframe")
        product_df = pd.DataFrame(columns=['SKU', 'ID', 'DETAIL'])
    except Exception as e:
        print(f"âš ï¸ Error loading product CSV: {e}, creating empty dataframe")
        product_df = pd.DataFrame(columns=['SKU', 'ID', 'DETAIL'])

    # Add region column before combining
    au_df['Region'] = 'AU'
    nz_df['Region'] = 'NZ'

    # Combine dataframes for the combined CSV download
    combined_df = pd.concat([au_df, nz_df], ignore_index=True)
    # Reorder columns to have Region first, then Timestamp (if exists), then others
    if 'Timestamp' in combined_df.columns:
        cols = ['Region', 'Timestamp'] + [col for col in combined_df.columns if col not in ['Region', 'Timestamp']]
    else:
        cols = ['Region'] + [col for col in combined_df.columns if col != 'Region']
    combined_df = combined_df[cols]
    # Combined CSV generation removed - not needed for GitHub workflow

    total_links_au = len(au_df[au_df['Region'] == 'AU']) # Filter by region just in case, though au_df is already AU
    broken_links_au = len(au_df[(au_df['Region'] == 'AU') & (au_df['Status'] >= 400)])
    total_links_nz = len(nz_df[nz_df['Region'] == 'NZ'])
    broken_links_nz = len(nz_df[(nz_df['Region'] == 'NZ') & (nz_df['Status'] >= 400)])

    # Create filtered dataframes for HTML tables (only errors)
    # The original au_df and nz_df are used for overall summary statistics
    au_error_df = au_df[au_df['Status'] >= 400].copy()
    nz_error_df = nz_df[nz_df['Status'] >= 400].copy()

    # Persist today's broken links to SQLite and enforce retention
    changes = {
        'yesterday': {'added': [], 'removed': [], 'has_data': False},
        'week': {'added': [], 'removed': [], 'has_data': False},
        'today_count': 0,
        'available_dates': []
    }
    try:
        conn = _connect_db(db_path)
        _ensure_retention(conn, keep_days=60)
        # Merge for storage to avoid two passes
        merged_err_df = pd.concat([au_error_df, nz_error_df], ignore_index=True)

        # Create sample historical data if needed for demonstration (fallback only)
        _create_sample_historical_data(conn, merged_err_df)
        print(f"Debug: Merged error dataframe has {len(merged_err_df)} rows")
        
        # Ensure required columns exist
        for col in ['Timestamp','Region','URL','Status','Response_Time','Error_Message']:
            if col not in merged_err_df.columns:
                merged_err_df[col] = ''
        
        # Add current timestamp if missing
        if 'Timestamp' not in merged_err_df.columns or merged_err_df['Timestamp'].isna().all():
            merged_err_df['Timestamp'] = datetime.now().isoformat()
        
        _store_broken_links_today(conn, merged_err_df)
        print(f"Debug: Stored {len(merged_err_df)} broken links to database")
        
        changes = _compute_changes(conn)
        print(f"Debug: Changes computed - Yesterday: {len(changes['yesterday']['added'])} added, {len(changes['yesterday']['removed'])} removed")
        print(f"Debug: Changes computed - Week: {len(changes['week']['added'])} added, {len(changes['week']['removed'])} removed")
        
        # Build a single combined CSV: Region, URL, Change, Window
        combined_rows = []
        for reg, url in changes['yesterday']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Yesterday"})
        for reg, url in changes['yesterday']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Yesterday"})
        for reg, url in changes['week']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Last 7 Days"})
        for reg, url in changes['week']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Last 7 Days"})
        
        try:
            pd.DataFrame(combined_rows, columns=["Region","URL","Change","Window"]).to_csv('changes_all.csv', index=False)
            print(f"Debug: Wrote {len(combined_rows)} changes to changes_all.csv")
        except Exception as e:
            print(f"Failed to write combined changes CSV: {e}")
            
    except Exception as e:
        print(f"Error in database operations: {e}")
        import traceback
        traceback.print_exc()
        # Initialize empty changes if database operations fail
        changes = {
            'yesterday': {'added': [], 'removed': [], 'has_data': False},
            'week': {'added': [], 'removed': [], 'has_data': False},
            'today_count': 0,
            'available_dates': []
        }
    finally:
        try:
            conn.close()
        except Exception:
            pass

    # Generate HTML tables using the filtered error dataframes
    # Drop 'Region' for individual table view; errors='ignore' handles cases where 'Region' might not exist (e.g., empty df)
    au_table_html = generate_html_table_from_df(au_error_df.drop(columns=['Region'], errors='ignore'), 'auLinkTable')
    nz_table_html = generate_html_table_from_df(nz_error_df.drop(columns=['Region'], errors='ignore'), 'nzLinkTable')

    # Generate product table HTML inline (replacing missing product_availability_ui module)
    def generate_product_availability_html(csv_path):
        """Generate product availability HTML table from CSV file with expandable details"""
        try:
            # Check if CSV file exists, try temp directory as fallback
            csv_file_to_use = csv_path
            try:
                pd.read_csv(csv_path, nrows=0)  # Just check if file can be read
            except (FileNotFoundError, pd.errors.EmptyDataError):
                # Try temp directory
                temp_csv_path = os.path.join('temp', 'product_export.csv')
                try:
                    pd.read_csv(temp_csv_path, nrows=0)
                    csv_file_to_use = temp_csv_path
                except (FileNotFoundError, pd.errors.EmptyDataError):
                    return "<p>No product data available.</p>"
            
            df = pd.read_csv(csv_file_to_use, encoding='utf-8', encoding_errors='replace')
            if df.empty:
                return "<p>No product data found in file.</p>"
            
            # Count total products
            total_products = len(df)
            
            # Generate HTML with proper wrapper structure
            html_content = f'''
        <div class="summary-container">
            <span class="summary-item">ðŸ“¦ Total Products: {total_products}</span>
        </div>
        
        <div class="product-availability-container">
            <div class="card">
                <h3>Product Availability</h3>
                <div class="table-container">
                    <table class="product-table">
                        <thead>
                            <tr>
                                <th>SKU</th>
                                <th>Product Name</th>
                                <th>Type</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody>
            '''
            
            for idx, row in df.iterrows():
                sku = str(row.get('SKU', '')) if pd.notna(row.get('SKU', '')) else ''
                
                # Parse JSON from DETAIL column
                product_data = {}
                try:
                    if pd.notna(row.get('DETAIL', '')):
                        detail_str = str(row['DETAIL'])
                        # Handle double-escaped JSON if needed
                        if detail_str.startswith('"') and detail_str.endswith('"'):
                            detail_str = detail_str[1:-1].replace('\\"', '"')
                        product_data = json.loads(detail_str)
                except Exception as e:
                    product_data = {}
                
                # Extract product name from JSON - check multiple possible keys
                product_name = product_data.get('ProductName', 
                              product_data.get('name', 
                              product_data.get('Name', 'Unknown Product')))
                
                # Determine if product is discontinued based on status or EndDate
                is_discontinued = False
                
                # Check status field first
                status = str(row.get('ID', '')).upper() if pd.notna(row.get('ID', '')) else ''
                if 'DISCONTINUED' in status:
                    is_discontinued = True
                
                # Also check EndDate in product data
                end_date = product_data.get('EndDate', '')
                if not end_date:
                    # Check nested attributes
                    end_date = product_data.get('attributes', {}).get('EndDate', '') if isinstance(product_data.get('attributes'), dict) else ''
                
                if end_date and str(end_date).strip():
                    try:
                        from datetime import datetime
                        # Try different date formats
                        for date_format in ['%Y-%m-%d', '%d %b %Y', '%Y-%m-%dT%H:%M:%S.%fZ']:
                            try:
                                end_date_obj = datetime.strptime(str(end_date), date_format)
                                if end_date_obj < datetime.now():
                                    is_discontinued = True
                                break
                            except:
                                continue
                    except:
                        pass
                
                # Product type badge
                product_type_class = 'discontinued' if is_discontinued else ''
                product_type_text = 'DISCONTINUED' if is_discontinued else 'ACTIVE'
                
                # Main product row
                html_content += f'<tr class="product-row" onclick="toggleProductDetails(\'product_{idx}\')">'
                html_content += f'<td><strong>{html.escape(sku)}</strong></td>'
                html_content += f'<td>{html.escape(product_name)}</td>'
                html_content += f'<td><span class="product-type-badge {product_type_class}">{product_type_text}</span></td>'
                html_content += f'<td><span class="toggle-icon" id="product_{idx}_toggle">â–¼</span></td>'
                html_content += '</tr>'
                
                # Details row (hidden by default)
                html_content += f'<tr id="product_{idx}_details" class="product-details-row" style="display: none;">'
                html_content += '<td colspan="4">'
                html_content += '<div class="product-details-content">'
                html_content += f'<h4>Product Details (SKU: {html.escape(sku)})</h4>'
                html_content += '<div class="attributes-section">'
                html_content += '<div class="attributes-container">'
                
                # Generate attributes from JSON data - handle both flat and nested structure
                attributes = {}
                
                # First, add all top-level attributes from product_data
                for key, value in product_data.items():
                    if key not in ['ProductName', 'name', 'Name'] and value is not None and str(value).strip():
                        attributes[key] = value
                
                # Then add nested attributes if they exist
                if 'attributes' in product_data and isinstance(product_data['attributes'], dict):
                    attributes.update(product_data['attributes'])
                
                if attributes:
                    for attr_name, attr_value in attributes.items():
                        if attr_value is not None and str(attr_value).strip():
                            value_str = str(attr_value)
                            
                            # Special handling for date fields
                            date_style = ''
                            if 'Date' in attr_name and value_str.strip():
                                try:
                                    for date_format in ['%Y-%m-%d', '%d %b %Y', '%Y-%m-%dT%H:%M:%S.%fZ']:
                                        try:
                                            date_obj = datetime.strptime(value_str, date_format)
                                            if date_obj < datetime.now():
                                                date_style = ' style="background-color: #fee2e2; color: #dc2626; padding: 2px 4px; border-radius: 3px; font-weight: 600;"'
                                            break
                                        except:
                                            continue
                                except:
                                    pass
                            
                            html_content += '<div class="attribute-item">'
                            html_content += f'<span class="attr-name"><strong>{html.escape(attr_name)}:</strong></span> '
                            html_content += f'<span class="attr-value"{date_style}>{html.escape(value_str)}</span>'
                            html_content += '</div>'
                else:
                    html_content += '<div class="no-attributes">No additional attributes available</div>'
                
                html_content += '</div></div></div></td></tr>'
            
            html_content += '''
                        </tbody>
                    </table>
                </div>
            </div>
        </div>'''
            return html_content
        except Exception as e:
            return f"<p>Error loading product data: {str(e)}</p>"
    
    product_table_html = generate_product_availability_html(product_csv_path)

    # Generate Page Views data by calling the newrelic_top_products.py script
    def generate_page_views_data():
        """Call the newrelic_top_products.py script to generate Page Views data (Top Products, Top Pages, Broken Links Views)"""
        try:
            # Run the newrelic_top_products.py script
            result = subprocess.run([sys.executable, 'newrelic_top_products.py'],
                                  capture_output=True, text=True, env=os.environ.copy())
            
            if result.returncode == 0:
                print("Page Views data generated successfully")
                # Check for Page Views content file in current directory
                page_views_file = 'page_views_content.html'
                try:
                    with open(page_views_file, 'r', encoding='utf-8', errors='replace') as f:
                        return f.read()
                except FileNotFoundError:
                    # Fallback to legacy file if new file missing
                    legacy_file = 'top_products_content.html'
                    try:
                        with open(legacy_file, 'r', encoding='utf-8', errors='replace') as f:
                            return f.read()
                    except FileNotFoundError:
                        return "<p>Page Views content file not found.</p>"
            else:
                print(f"Error running newrelic_top_products.py: {result.stderr}")
                return f"<p>Error generating Page Views data: {result.stderr}</p>"
        except Exception as e:
            print(f"Exception running newrelic_top_products.py: {str(e)}")
            return f"<p>Error generating Page Views data: {str(e)}</p>"
    
    page_views_html = generate_page_views_data()

    # Build Changes tab HTML
    def render_changes_section(title: str, items: list[tuple[str,str]], change_type: str):
        # items: list of (Region, URL)
        if not items:
            return "<p>No changes.</p>"
        
        # Create unique table ID based on title and change type
        table_id = f"changes-{change_type.lower()}-{title.lower().replace(' ', '-')}"
        table_class = f"changes-table-{change_type.lower()} display"
        
        # Add change type badge to each row
        badge_class = "added" if change_type.lower() == "added" else "removed"
        badge_text = "âž• ADDED" if change_type.lower() == "added" else "âž– REMOVED"
        
        rows = ''.join([
            f"<tr><td><span class='change-type-badge {badge_class}'>{badge_text}</span></td><td>{html.escape(reg)}</td><td><a href='{html.escape(url)}' target='_blank'>{html.escape(url)}</a></td></tr>" 
            for reg, url in items
        ])
        
        return f"""
            <table id='{table_id}' class='{table_class}' style='width:100%'>
                <thead><tr><th>Type</th><th>Region</th><th>URL</th></tr></thead>
                <tbody>{rows}</tbody>
            </table>
        """

    # Generate content for yesterday's changes
    if changes['yesterday']['has_data']:
        yesterday_content = f"""
                    <div class="changes-summary">
                        <div class="change-count added">âž• Added: {len(changes['yesterday']['added'])}</div>
                        <div class="change-count removed">âž– Removed: {len(changes['yesterday']['removed'])}</div>
                        <a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a>
                    </div>
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('yesterday-added-section')">
                            <span>Added Links ({len(changes['yesterday']['added'])})</span>
                            <span class="toggle-icon" id="yesterday-added-toggle">â–¼</span>
                        </div>
                        <div class="collapsible-content" id="yesterday-added-section">
                            {render_changes_section('Yesterday Added', changes['yesterday']['added'], 'added')}
                        </div>
                    </div>
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('yesterday-removed-section')">
                            <span>Removed Links ({len(changes['yesterday']['removed'])})</span>
                            <span class="toggle-icon" id="yesterday-removed-toggle">â–¼</span>
                        </div>
                        <div class="collapsible-content" id="yesterday-removed-section">
                            {render_changes_section('Yesterday Removed', changes['yesterday']['removed'], 'removed')}
                        </div>
                    </div>
        """
    else:
        yesterday_content = f"""
                    <div class="changes-summary">
                        <div style="padding: 20px; text-align: center; color: #6c757d; font-style: italic;">
                            ðŸ“Š No historical data available to compare with yesterday's broken links.<br>
                            <small style="margin-top: 8px; display: block;">
                                Current database contains {changes.get('today_count', 'N/A')} broken links from today.
                                Historical comparison will be available after running the link checker on multiple days.
                            </small>
                        </div>
                    </div>
        """
    
    # Generate content for week's changes
    if changes['week']['has_data']:
        week_content = f"""
                    <div class="changes-summary">
                        <div class="change-count added">âž• Added: {len(changes['week']['added'])}</div>
                        <div class="change-count removed">âž– Removed: {len(changes['week']['removed'])}</div>
                        <a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a>
                    </div>
                    
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('week-added-section')">
                            <span>âž• Added Links ({len(changes['week']['added'])})</span>
                            <span class="toggle-icon" id="week-added-toggle">â–¼</span>
                        </div>
                        <div class="collapsible-content" id="week-added-section">
                            {render_changes_section('Added Week', changes['week']['added'], 'added')}
                        </div>
                    </div>
                    
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('week-removed-section')">
                            <span>âž– Removed Links ({len(changes['week']['removed'])})</span>
                            <span class="toggle-icon" id="week-removed-toggle">â–¼</span>
                        </div>
                        <div class="collapsible-content" id="week-removed-section">
                            {render_changes_section('Removed Week', changes['week']['removed'], 'removed')}
                        </div>
                    </div>
        """
    else:
        week_content = f"""
                    <div class="changes-summary">
                        <div style="padding: 20px; text-align: center; color: #6c757d; font-style: italic;">
                            ðŸ“Š No historical data available to compare with 7 days ago broken links.<br>
                            <small style="margin-top: 8px; display: block;">
                                Current database contains {changes.get('today_count', 'N/A')} broken links from today.
                                Weekly comparison will be available after running the link checker for multiple days.
                            </small>
                        </div>
                    </div>
        """

    changes_html = f"""
        <div id="Changes" class="tab-content">
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleSection('yesterday-section')">
                    <span>Changes since Yesterday</span>
                    <span class="toggle-icon" id="yesterday-toggle">â–¼</span>
                </div>
                <div class="collapsible-content" id="yesterday-section">
{yesterday_content}
                </div>
            </div>

            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleSection('week-section')">
                    <span>Changes vs 7 Days Ago</span>
                    <span class="toggle-icon" id="week-toggle">â–¼</span>
                </div>
                <div class="collapsible-content" id="week-section">
{week_content}
                </div>
            </div>
        </div>
    """

    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Broken Link Report</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
        <script src="auth.js"></script>
        <style>
            {STYLE_DEFINITIONS}
        </style>
    </head>
    <body>
        <button onclick="scrollToTop()" id="scrollTopBtn" title="Go to top">&#x2191;</button> <!-- Up arrow -->
        <button onclick="scrollToBottom()" id="scrollBottomBtn" title="Go to bottom">&#x2193;</button> <!-- Down arrow -->
        <header>
            <h1>Kmart Link Check Report</h1>
        </header>
        <div class="container">
        <!-- <a href="combined_link_check_results.csv" download class="download-button">Download Combined CSV</a> --> <!-- Removed combined CSV download link -->

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-link active" onclick="openTab(event, 'AU_Report')">AU</button>
                <button class="tab-link" onclick="openTab(event, 'NZ_Report')">NZ</button>
                <button class="tab-link" onclick="openTab(event, 'Changes')">Changes</button>
                <button class="tab-link" onclick="openTab(event, 'Product_Availability')">Product Availability</button>
                <button class="tab-link" onclick="openTab(event, 'Page_Views')">Page Views</button>
                <!-- Categories tab disabled -->
            </div>

            <div id="AU_Report" class="tab-content" style="display: block;">
                <div class="summary-container">
                    <span class="summary-item">ðŸ” Total Links Checked (AU): {total_links_au}</span>
                    <span class="summary-item">âŒ Broken Links (AU): {broken_links_au}</span>
                    <span class="summary-item">âœ… Valid Links (AU): {total_links_au - broken_links_au}</span>
                    <span class="summary-item"><a href="au_link_check_results.csv" download class="download-tab-button">Download AU Full CSV</a></span>
                </div>
                {au_table_html}
            </div>

            <div id="NZ_Report" class="tab-content">
                <div class="summary-container">
                    <span class="summary-item">ðŸ” Total Links Checked (NZ): {total_links_nz}</span>
                    <span class="summary-item">âŒ Broken Links (NZ): {broken_links_nz}</span>
                    <span class="summary-item">âœ… Valid Links (NZ): {total_links_nz - broken_links_nz}</span>
                    <span class="summary-item"><a href="nz_link_check_results.csv" download class="download-tab-button">Download NZ Full CSV</a></span>
                </div>
                {nz_table_html}
            </div>

            {changes_html}

            <div id="Product_Availability" class="tab-content">
                {product_table_html}
            </div>

            <div id="Page_Views" class="tab-content">
                {page_views_html}
            </div>

            <!-- Categories tab content disabled -->
        </div>
        </div>

        <script>
            function openTab(evt, reportName) {{
                var i, tabcontent, tablinks;
                tabcontent = document.getElementsByClassName("tab-content");
                for (i = 0; i < tabcontent.length; i++) {{
                    tabcontent[i].style.display = "none";
                }}
                tablinks = document.getElementsByClassName("tab-link");
                for (i = 0; i < tablinks.length; i++) {{
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }}
                document.getElementById(reportName).style.display = "block";
                evt.currentTarget.className += " active";
            }}

            $(document).ready(function() {{
                ['#auLinkTable', '#nzLinkTable'].forEach(function(tableId) {{
                    if (!$(tableId).length) return; // If table doesn't exist, skip

                    var table = $(tableId).DataTable({{
                        pageLength: 100,
                        orderCellsTop: true,
                        fixedHeader: true,
                        initComplete: function () {{
                            var api = this.api();
                            // Check for the correct number of filterable columns (Timestamp, URL, Status, Response_Time, Error_Message)
                            var filterHeaderCells = $(tableId + ' thead tr.filters th');
                            if (filterHeaderCells.length !== 5) {{
                                console.error('Expected 5 filterable columns for ' + tableId + ', found ' + filterHeaderCells.length + '. Skipping filter setup.');
                                return;
                            }}

                            api.columns().eq(0).each(function (colIdx) {{
                                // Get the input element for the current column's filter
                                var inputElement = $(filterHeaderCells[colIdx]).find('input');
                                
                                $(inputElement)
                                    .off('keyup change') // Remove previous event handlers to prevent duplicates
                                    .on('keyup change', function (e) {{
                                        e.stopPropagation();
                                        // Perform search, treating input as literal string (regex: false, smart: false)
                                        var searchValue = this.value;
                                        api.column(colIdx).search(searchValue, false, false).draw();
                                        
                                        // Restore cursor position if the element is still focused
                                        if (document.activeElement === this) {{
                                            var cursorPos = this.selectionStart;
                                            this.focus();
                                            this.setSelectionRange(cursorPos, cursorPos);
                                        }}
                                    }});
                            }});
                        }},
                        rowCallback: function(row, data, index){{
                             var statusCell = data[2]; // Status is now at index 2 (Timestamp, URL, Status, ...)
                             var status = parseInt(statusCell) || 0;
                             $(row).removeClass('ok error redirect');
                            if (status >= 400) {{
                                $(row).addClass('error');
                            }} else if (status >= 300) {{
                                $(row).addClass('redirect');
                            }} else if (status === 200) {{
                                $(row).addClass('ok');
                            }}
                        }}
                    }});
                }});
                
                // Initialize DataTables for changes tables
                var changesTables = [
                    '#yesterday-added-table', '#yesterday-removed-table',
                    '#week-added-table', '#week-removed-table'
                ];
                
                changesTables.forEach(function(tableId) {{
                    if (!$(tableId).length) return; // If table doesn't exist, skip
                    
                    $(tableId).DataTable({{
                        pageLength: 50,
                        orderCellsTop: true,
                        fixedHeader: true,
                        dom: 'Bfrtip',
                        buttons: [
                            'copy', 'csv', 'excel', 'pdf', 'print'
                        ],
                        order: [[2, 'asc']] // Sort by URL column
                    }});
                }});

                // Initialize DataTables for Page Views inner tables if present
                ['#topProductsTable', '#topPagesTable', '#brokenLinksViewsTable'].forEach(function(tid) {{
                    if (!$(tid).length) return;
                    $(tid).DataTable({{
                        pageLength: 50,
                        orderCellsTop: true,
                        fixedHeader: true
                    }});
                }});
            }});
            
            // Scroll buttons logic
            var scrollTopButton = document.getElementById("scrollTopBtn");
            var scrollBottomButton = document.getElementById("scrollBottomBtn");
            var pageBody = document.body;
            var pageDocumentElement = document.documentElement;

            window.onscroll = function() {{scrollFunction()}};

            function scrollFunction() {{
                // Show scrollTopBtn if scrolled down, hide if near the top
                if (scrollTopButton) {{
                    if (pageBody.scrollTop > 30 || pageDocumentElement.scrollTop > 30) {{
                        scrollTopButton.style.display = "block";
                    }} else {{
                        scrollTopButton.style.display = "none";
                    }}
                }}

                // Show scrollBottomBtn if not near the bottom, hide if at the bottom.
                // Also ensure it's shown if page is scrollable at all from the top
                if (scrollBottomButton) {{
                    let isPageScrollable = pageDocumentElement.scrollHeight > pageDocumentElement.clientHeight;
                    let isAtBottom = (window.innerHeight + window.scrollY) >= pageDocumentElement.offsetHeight - 30; // 30px buffer

                    if (isPageScrollable && !isAtBottom) {{
                        scrollBottomButton.style.display = "block";
                    }} else {{
                        scrollBottomButton.style.display = "none";
                    }}
                }}
            }}
            // Initial check in case the page loads scrolled or is too short to scroll
            scrollFunction();

            // Assign functions to window so inline onclick can find them
            window.scrollToTop = function() {{ 
                pageBody.scrollTop = 0; // For Safari
                pageDocumentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }};
            window.scrollToBottom = function() {{
                pageBody.scrollTop = pageDocumentElement.scrollHeight; // For Safari
                pageDocumentElement.scrollTop = pageDocumentElement.scrollHeight; // For Chrome, Firefox, IE and Opera
            }};
            
            // Toggle functionality for collapsible sections
            window.toggleSection = function(sectionId) {{
                var content = document.getElementById(sectionId);
                var toggleIcon = document.getElementById(sectionId.replace('-section', '-toggle'));
                var header = content.previousElementSibling;
                
                if (content.classList.contains('active')) {{
                    content.classList.remove('active');
                    header.classList.remove('active');
                    toggleIcon.textContent = 'â–¼';
                    toggleIcon.classList.remove('rotated');
                }} else {{
                    content.classList.add('active');
                    header.classList.add('active');
                    toggleIcon.textContent = 'â–²';
                    toggleIcon.classList.add('rotated');
                }}
            }};
            
            // Category tab functionality
            window.openCategory = function(evt, categoryName) {{
                var i, categoryContent, categoryTabs;
                categoryContent = document.getElementsByClassName('category-content');
                for (i = 0; i < categoryContent.length; i++) {{
                    categoryContent[i].classList.remove('active');
                }}
                categoryTabs = document.getElementsByClassName('category-tab');
                for (i = 0; i < categoryTabs.length; i++) {{
                    categoryTabs[i].classList.remove('active');
                }}
                document.getElementById(categoryName).classList.add('active');
                evt.currentTarget.classList.add('active');
            }};

            // Product Availability JavaScript Functions
            window.toggleProductDetails = function(rowId) {{
                var detailsRow = document.getElementById(rowId + '_details');
                var toggleIcon = document.getElementById(rowId + '_toggle');

                if (detailsRow.style.display === 'none' || detailsRow.style.display === '') {{
                    detailsRow.style.display = 'table-row';
                    toggleIcon.textContent = 'â–²';
                    toggleIcon.classList.add('rotated');
                }} else {{
                    detailsRow.style.display = 'none';
                    toggleIcon.textContent = 'â–¼';
                    toggleIcon.classList.remove('rotated');
                }}
            }};
        </script>
    </body>
    </html>
    """

    with open(output_html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"âœ… Combined HTML report saved to {output_html_path}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate a combined HTML report for AU and NZ link checks.')
    parser.add_argument('--au-csv', default='au_link_check_results.csv', help='Path to the AU link check results CSV file.')
    parser.add_argument('--nz-csv', default='nz_link_check_results.csv', help='Path to the NZ link check results CSV file.')
    parser.add_argument('--product-csv', default='product_export.csv', help='Path to the product data CSV file.')
    parser.add_argument('--output-html', default='combined_report.html', help='Path to save the combined HTML report.')
    args = parser.parse_args()

    generate_combined_html_report(args.au_csv, args.nz_csv, args.output_html, args.product_csv)
