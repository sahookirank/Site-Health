import pandas as pd
import argparse
import html
import os
import sqlite3
from datetime import date, timedelta, datetime
import plotly.graph_objects as go
import plotly.express as px
import networkx as nx
import json
from urllib.parse import urlparse

# Security Note: The HTML is generated by embedding data directly. 
# While the data (URLs, paths, statuses) is generally from crawling trusted sites or self-generated,
# for broader applications, using a templating engine (like Jinja2) would be a safer practice 
# to prevent potential XSS if data sources were less controlled.

def generate_html_table_from_df(df, table_id):
    """Generates an HTML table string from a pandas DataFrame for use with DataTables."""
    if df.empty:
        return f"<p>No data available for {table_id.replace('Table', '')}.</p>"

    table_html = f'''
    <table id="{table_id}" class="display" style="width:100%">
        <thead>
            <tr>{''.join(f'<th>{col}</th>' for col in df.columns)}</tr>
            <tr class="filters">{''.join("<th><input type='text' placeholder='Filter ...' style='width: 90%;' /></th>" for _ in df.columns)}</tr>
        </thead>
        <tbody>
'''
    for _, row in df.iterrows():
        status_val = row.get("Status", "N/A") # Get status, default to N/A if not present
        try:
            status = int(float(status_val)) if pd.notna(status_val) else 0
        except ValueError:
            status = 0 # Default for non-integer statuses

        cls = "ok" if status == 200 else "redirect" if 300 <= status < 400 else "error"
        table_html += f"<tr class='{cls}'>"
        for col, val in row.items():
            # Ensure HTML special characters in data are escaped to prevent XSS. Pandas to_html does this by default.
            # Here, we are manually creating cells, so care is needed. For URLs, it's common to allow them as hrefs.
            # For other text, escaping would be important if it could come from untrusted input.
            # Given the source of this data, direct embedding is lower risk but not best practice.
            escaped_val = html.escape(str(val))
            if col == "URL":
                table_html += f"<td><a href='{escaped_val}' target='_blank'>{escaped_val}</a></td>"
            else:
                table_html += f"<td>{escaped_val}</td>"
        table_html += "</tr>"
    table_html += """
        </tbody>
    </table>
"""
    return table_html

STYLE_DEFINITIONS = """
            :root {
                --container-max: 1400px;
                --brand: #0d6efd;
                --muted-bg: #f6f7f9;
                --muted: #6c757d;
                --card-bg: #ffffff;
                --border: #e5e7eb;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                margin: 0;
                background-color: var(--muted-bg);
                color: #1f2937;
            }
            header {
                background: linear-gradient(180deg, #fff, #fafbfc);
                border-bottom: 1px solid var(--border);
                padding: 24px 16px 16px;
                margin-bottom: 16px;
            }
            h1 {
                text-align: center;
                margin: 0 auto;
                max-width: var(--container-max);
                font-weight: 700;
                letter-spacing: .2px;
            }
            .container {
                max-width: var(--container-max);
                margin: 0 auto;
                padding: 0 16px 24px;
            }
            .summary-container {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                margin-bottom: 16px;
            }
            .summary-item {
                background-color: #eef2f7;
                padding: 10px 14px;
                border-radius: 999px;
                font-size: 14px;
                border: 1px solid var(--border);
            }
            .tab-container {
                margin-top: 12px;
                background-color: var(--card-bg);
                padding: 0 0 16px;
                border-radius: 12px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.06);
                border: 1px solid var(--border);
            }
            .tab-buttons {
                display: flex;
                gap: 12px;
                padding: 12px;
                border-bottom: 1px solid var(--border);
                background: #fff;
                position: sticky;
                top: 0;
                z-index: 10;
            }
            .tab-link {
                background-color: #f3f4f6;
                border: 1px solid var(--border);
                padding: 12px 24px;
                cursor: pointer;
                border-radius: 10px;
                font-weight: 700;
                font-size: 15px;
                letter-spacing: .2px;
                min-width: 160px;
                transition: all .15s ease;
            }
            .tab-link.active, .tab-link:hover {
                background-color: #e9effe;
                border-color: #c2d3ff;
                color: #0b3fbf;
            }
            .tab-content {
                display: none;
                padding: 16px;
            }
            .card {
                background: #fff;
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 14px;
                box-shadow: 0 2px 10px rgba(0,0,0,.04);
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                background: #fff;
                border-radius: 8px;
                overflow: hidden;
            }
            th, td {
                text-align: left;
                padding: 10px 12px;
                border-bottom: 1px solid #eee;
            }
            th {
                background-color: #f8fafc;
                color: #111827;
            }
            .download-button {
                display: inline-block;
                margin: 10px 0;
                padding: 10px 15px;
                background-color: var(--brand);
                color: white;
                text-decoration: none;
                border-radius: 6px;
            }
            .download-button:hover { filter: brightness(.95); }
            #scrollTopBtn, #scrollBottomBtn {
                position: fixed;
                right: 20px;
                padding: 10px;
                font-size: 18px;
                border: none;
                border-radius: 8px;
                background-color: var(--brand);
                color: white;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            }
            #scrollTopBtn { bottom: 80px; }
            #scrollBottomBtn { bottom: 24px; }
            .download-tab-button {
                display: inline-block;
                padding: 8px 12px;
                background-color: #6c757d;
                color: white;
                text-decoration: none;
                border-radius: 999px;
                margin-left: 10px;
                font-size: 12px;
                border: 1px solid var(--border);
            }
            .download-tab-button:hover { filter: brightness(.95); }
            .collapsible-section {
                margin: 20px 0;
                border: 1px solid var(--border);
                border-radius: 10px;
                overflow: hidden;
            }
            .collapsible-header {
                background: linear-gradient(135deg, #f8fafc, #e2e8f0);
                padding: 16px 20px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
                border-bottom: 1px solid var(--border);
            }
            .collapsible-header:hover {
                background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
            }
            .collapsible-header.active {
                background: linear-gradient(135deg, #dbeafe, #bfdbfe);
                color: #1e40af;
            }
            .collapsible-content {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
                background: #fff;
            }
            .collapsible-content.active {
                max-height: none;
                padding: 20px;
            }
            /* New styles for changes tables */
            .changes-table-added tbody tr {
                background-color: #f0fdf4 !important;
                border-left: 4px solid #22c55e;
            }
            .changes-table-added tbody tr:hover {
                background-color: #dcfce7 !important;
            }
            .changes-table-removed tbody tr {
                background-color: #fef2f2 !important;
                border-left: 4px solid #ef4444;
            }
            .changes-table-removed tbody tr:hover {
                background-color: #fecaca !important;
            }
            .change-type-badge {
                display: inline-block;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 12px;
                font-weight: 600;
                text-transform: uppercase;
            }
            .change-type-badge.added {
                background-color: #dcfce7;
                color: #166534;
                border: 1px solid #86efac;
            }
            .change-type-badge.removed {
                background-color: #fef2f2;
                color: #991b1b;
                border: 1px solid #fca5a5;
            }
            .toggle-icon {
                font-size: 18px;
                transition: transform 0.3s ease;
            }
            .toggle-icon.rotated {
                transform: rotate(180deg);
            }
            .changes-summary {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
                flex-wrap: wrap;
            }
            .change-count {
                padding: 12px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 14px;
                min-width: 120px;
                text-align: center;
            }
            .change-count.added {
                background: linear-gradient(135deg, #dcfce7, #bbf7d0);
                color: #166534;
                border: 1px solid #86efac;
            }
            .change-count.removed {
                background: linear-gradient(135deg, #fef2f2, #fecaca);
                color: #991b1b;
                border: 1px solid #fca5a5;
            }
            .visualization-container {
                background: #fff;
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 20px;
                margin: 16px 0;
                box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            }
            .category-tabs {
                display: flex;
                gap: 8px;
                margin-bottom: 20px;
                border-bottom: 2px solid var(--border);
            }
            .category-tab {
                padding: 12px 24px;
                background: #f8fafc;
                border: 1px solid var(--border);
                border-bottom: none;
                border-radius: 8px 8px 0 0;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.2s ease;
            }
            .category-tab.active {
                background: #fff;
                border-bottom: 2px solid #fff;
                margin-bottom: -2px;
                color: var(--brand);
            }
            .category-content {
                display: none;
            }
            .category-content.active {
                display: block;
            }
"""

def extract_category_hierarchy(df, region):
    """Extract hierarchical category data from URLs and store in temporary file."""
    if df.empty:
        return {}
    
    category_hierarchy = {}
    
    for _, row in df.iterrows():
        try:
            url = row['URL']
            parsed = urlparse(url)
            path = parsed.path.strip('/')
            
            if path:
                segments = path.split('/')
                # Look for category patterns
                for i, segment in enumerate(segments):
                    if 'category' in segment.lower() or 'categories' in segment.lower():
                        # This is a category segment
                        if i + 1 < len(segments):
                            category_name = segments[i + 1].replace('-', ' ').replace('_', ' ').title()
                            
                            if category_name not in category_hierarchy:
                                category_hierarchy[category_name] = {
                                    'count': 0,
                                    'subcategories': set(),
                                    'urls': []
                                }
                            
                            category_hierarchy[category_name]['count'] += 1
                            category_hierarchy[category_name]['urls'].append(url)
                            
                            # Check for subcategories
                            if i + 2 < len(segments):
                                subcategory = segments[i + 2].replace('-', ' ').replace('_', ' ').title()
                                category_hierarchy[category_name]['subcategories'].add(subcategory)
                    
                    # Also check for direct category names in path
                    elif segment.lower() in ['home', 'clothing', 'electronics', 'toys', 'beauty', 'garden', 'sports', 'outdoor', 'tech', 'baby', 'kids']:
                        category_name = segment.replace('-', ' ').replace('_', ' ').title()
                        
                        if category_name not in category_hierarchy:
                            category_hierarchy[category_name] = {
                                'count': 0,
                                'subcategories': set(),
                                'urls': []
                            }
                        
                        category_hierarchy[category_name]['count'] += 1
                        category_hierarchy[category_name]['urls'].append(url)
                        
                        # Check for subcategories
                        if i + 1 < len(segments):
                            subcategory = segments[i + 1].replace('-', ' ').replace('_', ' ').title()
                            category_hierarchy[category_name]['subcategories'].add(subcategory)
        except Exception:
            continue
    
    # Convert sets to lists for JSON serialization
    for category in category_hierarchy:
        category_hierarchy[category]['subcategories'] = list(category_hierarchy[category]['subcategories'])
    
    # Save to temporary file
    temp_file = f'temp/{region.lower()}_categories.json'
    os.makedirs('temp', exist_ok=True)
    
    with open(temp_file, 'w') as f:
        json.dump(category_hierarchy, f, indent=2)
    
    return category_hierarchy

def generate_site_architecture_visualization(df, region):
    """Generate interactive site architecture visualization using Plotly and NetworkX."""
    if df.empty:
        return "<p>No data available for visualization.</p>"
    
    # Extract domain and path information
    urls = df['URL'].dropna().tolist()
    
    # Create a network graph
    G = nx.DiGraph()
    
    # Parse URLs and create hierarchical structure
    domain_paths = {}
    for url in urls:
        try:
            parsed = urlparse(url)
            domain = parsed.netloc
            path = parsed.path.strip('/')
            
            if domain not in domain_paths:
                domain_paths[domain] = set()
            
            # Split path into segments
            if path:
                segments = path.split('/')
                # Add hierarchical relationships
                current_path = ''
                for i, segment in enumerate(segments):
                    parent_path = current_path
                    current_path = '/'.join(segments[:i+1]) if current_path else segment
                    
                    if parent_path:
                        G.add_edge(f"{domain}/{parent_path}", f"{domain}/{current_path}")
                    else:
                        G.add_edge(domain, f"{domain}/{current_path}")
                    
                    domain_paths[domain].add(current_path)
            else:
                G.add_node(domain)
        except Exception:
            continue
    
    if not G.nodes():
        return "<p>No valid URLs found for visualization.</p>"
    
    # Create layout
    try:
        pos = nx.spring_layout(G, k=3, iterations=50)
    except:
        pos = {node: (0, 0) for node in G.nodes()}
    
    # Extract node and edge information
    node_x = []
    node_y = []
    node_text = []
    node_colors = []
    
    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        node_text.append(node)
        # Color nodes based on type (domain vs path)
        if '/' in node and node.count('/') > 1:
            node_colors.append('#ff7f0e')  # Orange for deep paths
        elif '/' in node:
            node_colors.append('#2ca02c')  # Green for first-level paths
        else:
            node_colors.append('#1f77b4')  # Blue for domains
    
    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])
    
    # Create Plotly figure
    fig = go.Figure()
    
    # Add edges
    fig.add_trace(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=1, color='#888'),
        hoverinfo='none',
        mode='lines',
        name='Connections'
    ))
    
    # Add nodes
    fig.add_trace(go.Scatter(
        x=node_x, y=node_y,
        mode='markers+text',
        hoverinfo='text',
        text=node_text,
        textposition="middle center",
        marker=dict(
            size=20,
            color=node_colors,
            line=dict(width=2, color='white')
        ),
        name='Pages'
    ))
    
    fig.update_layout(
        title=dict(text=f'{region} Site Architecture', font=dict(size=16)),
        showlegend=False,
        hovermode='closest',
        margin=dict(b=20,l=5,r=5,t=40),
        annotations=[
            dict(
                text=f"Interactive visualization of {region} site structure",
                showarrow=False,
                xref="paper", yref="paper",
                x=0.005, y=-0.002,
                xanchor="left", yanchor="bottom",
                font=dict(color="#888", size=12)
            )
        ],
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor='white'
    )
    
    return fig.to_html(include_plotlyjs='cdn', div_id=f'{region.lower()}_architecture')

def generate_navigation_hierarchy_chart(df, region):
    """Generate a hierarchical chart showing navigation structure."""
    if df.empty:
        return "<p>No data available for navigation hierarchy.</p>"
    
    # Extract path hierarchy
    path_counts = {}
    for _, row in df.iterrows():
        try:
            url = row['URL']
            parsed = urlparse(url)
            path = parsed.path.strip('/')
            
            if path:
                segments = path.split('/')
                for i, segment in enumerate(segments):
                    level = i + 1
                    if level not in path_counts:
                        path_counts[level] = {}
                    if segment not in path_counts[level]:
                        path_counts[level][segment] = 0
                    path_counts[level][segment] += 1
        except Exception:
            continue
    
    if not path_counts:
        return "<p>No navigation hierarchy found.</p>"
    
    # Create sunburst chart
    labels = []
    parents = []
    values = []
    
    # Add root
    labels.append(f'{region} Root')
    parents.append('')
    values.append(len(df))
    
    # Add hierarchy levels
    for level in sorted(path_counts.keys()):
        for segment, count in path_counts[level].items():
            labels.append(segment)
            if level == 1:
                parents.append(f'{region} Root')
            else:
                parents.append('')  # Simplified for demo
            values.append(count)
    
    fig = go.Figure(go.Sunburst(
        labels=labels,
        parents=parents,
        values=values,
        branchvalues="total",
    ))
    
    fig.update_layout(
        title=f'{region} Navigation Hierarchy',
        font_size=12,
        margin=dict(t=50, l=0, r=0, b=0)
    )
    
    return fig.to_html(include_plotlyjs='cdn', div_id=f'{region.lower()}_hierarchy')

def generate_category_hierarchy_visualization(df, region):
    """Generate scattered category visualization with expandable details."""
    if df.empty:
        return "<p>No data available for category visualization.</p>"
    
    # Extract category hierarchy
    category_data = extract_category_hierarchy(df, region)
    
    if not category_data:
        return "<p>No categories found in the data.</p>"
    
    # Generate HTML for category visualization
    html_content = f"""
    <div class="category-hierarchy-container">
        <h3>{region} Category Hierarchy</h3>
        <div class="categories-grid">
    """
    
    for category, data in category_data.items():
        subcategories_html = ""
        if data['subcategories']:
            subcategories_html = "<ul class='subcategories-list'>" + "".join([
                f"<li>{sub}</li>" for sub in data['subcategories']
            ]) + "</ul>"
        
        html_content += f"""
        <div class="category-card">
            <div class="category-header" onclick="toggleCategoryDetails('{region.lower()}_{category.replace(' ', '_')}')">
                <span class="category-name">{category}</span>
                <span class="category-count">({data['count']} links)</span>
                <span class="expand-icon" id="{region.lower()}_{category.replace(' ', '_')}_icon">▼</span>
            </div>
            <div class="category-details" id="{region.lower()}_{category.replace(' ', '_')}_details">
                {subcategories_html if subcategories_html else '<p class="no-subcategories">No subcategories found</p>'}
                <div class="category-urls">
                    <strong>Sample URLs:</strong>
                    <ul>
                        {''.join([f'<li><a href="{url}" target="_blank">{url[:50]}...</a></li>' for url in data['urls'][:3]])}
                    </ul>
                </div>
            </div>
        </div>
        """
    
    html_content += """
        </div>
    </div>
    
    <style>
    .category-hierarchy-container {
        margin: 20px 0;
        padding: 20px;
        background: #f8fafc;
        border-radius: 12px;
        border: 1px solid #e2e8f0;
    }
    
    .categories-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 16px;
        margin-top: 16px;
    }
    
    .category-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        transition: all 0.2s ease;
    }
    
    .category-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-1px);
    }
    
    .category-header {
        padding: 16px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
    }
    
    .category-name {
        font-size: 16px;
        flex-grow: 1;
    }
    
    .category-count {
        background: rgba(255,255,255,0.2);
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        margin: 0 8px;
    }
    
    .expand-icon {
        font-size: 14px;
        transition: transform 0.3s ease;
    }
    
    .expand-icon.rotated {
        transform: rotate(180deg);
    }
    
    .category-details {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        background: white;
    }
    
    .category-details.expanded {
        max-height: 500px;
        padding: 16px;
    }
    
    .subcategories-list {
        margin: 0 0 16px 0;
        padding: 0;
        list-style: none;
    }
    
    .subcategories-list li {
        background: #f1f5f9;
        padding: 8px 12px;
        margin: 4px 0;
        border-radius: 6px;
        border-left: 3px solid #3b82f6;
    }
    
    .no-subcategories {
        color: #64748b;
        font-style: italic;
        margin: 0 0 16px 0;
    }
    
    .category-urls ul {
        margin: 8px 0 0 0;
        padding: 0;
        list-style: none;
    }
    
    .category-urls li {
        margin: 4px 0;
    }
    
    .category-urls a {
        color: #3b82f6;
        text-decoration: none;
        font-size: 12px;
    }
    
    .category-urls a:hover {
        text-decoration: underline;
    }
    </style>
    
    <script>
    function toggleCategoryDetails(categoryId) {
        const details = document.getElementById(categoryId + '_details');
        const icon = document.getElementById(categoryId + '_icon');
        
        if (details.classList.contains('expanded')) {
            details.classList.remove('expanded');
            icon.classList.remove('rotated');
            icon.textContent = '▼';
        } else {
            details.classList.add('expanded');
            icon.classList.add('rotated');
            icon.textContent = '▲';
        }
    }
    </script>
    """
    
    return html_content

def _connect_db(db_path: str = 'broken_links.db'):
    conn = sqlite3.connect(db_path)
    return conn

def _ensure_retention(conn: sqlite3.Connection, keep_days: int = 60):
    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%';")
    tables = [r[0] for r in cur.fetchall()]
    cutoff = date.today() - timedelta(days=keep_days)
    for t in tables:
        try:
            d_str = t.replace('broken_links_', '')
            d = datetime.strptime(d_str, '%Y_%m_%d').date()
        except Exception:
            continue
        if d < cutoff:
            cur.execute(f'DROP TABLE IF EXISTS {t}')
    conn.commit()

def _store_broken_links_today(conn: sqlite3.Connection, df: pd.DataFrame):
    # df expected columns include Region, URL, Status, Response_Time, Error_Message, Timestamp
    today_str = date.today().strftime('%Y_%m_%d')
    table = f"broken_links_{today_str}"
    cur = conn.cursor()
    cur.execute(f"""
        CREATE TABLE IF NOT EXISTS {table} (
            Region TEXT,
            URL TEXT,
            Status INTEGER,
            Response_Time REAL,
            Error_Message TEXT,
            Timestamp TEXT
        )
    """)
    # Clear existing records for today to prevent duplicates
    cur.execute(f"DELETE FROM {table}")
    # Insert rows
    records = df[df['Status'] >= 400][['Region','URL','Status','Response_Time','Error_Message','Timestamp']].to_records(index=False)
    cur.executemany(
        f"INSERT INTO {table} (Region, URL, Status, Response_Time, Error_Message, Timestamp) VALUES (?,?,?,?,?,?)",
        list(records)
    )
    conn.commit()

def _load_broken_set(conn: sqlite3.Connection, target_date: date) -> set[tuple[str, str]]:
    table = f"broken_links_{target_date.strftime('%Y_%m_%d')}"
    cur = conn.cursor()
    try:
        cur.execute(f"SELECT Region, URL FROM {table}")
    except sqlite3.OperationalError:
        return set()
    return set(cur.fetchall())

def _compute_changes(conn: sqlite3.Connection):
    # Dynamically detect available dates from database tables
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'broken_links_%'")
    tables = [row[0] for row in cursor.fetchall()]
    
    # Extract dates from table names and sort them
    available_dates = []
    for table in tables:
        if table.startswith('broken_links_'):
            date_str = table.replace('broken_links_', '')
            try:
                # Parse date format: YYYY_MM_DD
                year, month, day = map(int, date_str.split('_'))
                available_dates.append(date(year, month, day))
            except ValueError:
                continue
    
    available_dates.sort(reverse=True)  # Most recent first
    
    if len(available_dates) == 0:
        # No data available
        return {
            'yesterday': {'added': [], 'removed': [], 'has_data': False},
            'week': {'added': [], 'removed': [], 'has_data': False}
        }
    
    # Use the most recent date as "today"
    today_d = available_dates[0]
    
    # Find the closest previous date for "yesterday" comparison
    yday_d = None
    for d in available_dates[1:]:
        if d < today_d:
            yday_d = d
            break
    
    # Find a date approximately 7 days before today for "week" comparison
    week_d = None
    target_week_date = today_d - timedelta(days=7)
    for d in available_dates:
        if d <= target_week_date:
            week_d = d
            break
    
    today_set = _load_broken_set(conn, today_d)
    yday_set = _load_broken_set(conn, yday_d) if yday_d else set()
    week_set = _load_broken_set(conn, week_d) if week_d else set()
    
    # Check if we have data to compare
    has_yesterday_data = len(yday_set) > 0
    has_week_data = len(week_set) > 0
    
    # Added = in today but not in past; Removed = in past but not in today
    if has_yesterday_data:
        y_added = sorted(list(today_set - yday_set))
        y_removed = sorted(list(yday_set - today_set))
    else:
        y_added = []
        y_removed = []
    
    if has_week_data:
        w_added = sorted(list(today_set - week_set))
        w_removed = sorted(list(week_set - today_set))
    else:
        w_added = []
        w_removed = []
    
    return {
        'yesterday': {
            'added': y_added, 
            'removed': y_removed,
            'has_data': has_yesterday_data
        },
        'week': {
            'added': w_added, 
            'removed': w_removed,
            'has_data': has_week_data
        }
    }

def generate_combined_html_report(au_csv_path, nz_csv_path, output_html_path='combined_report.html', db_path: str = 'broken_links.db'):
    """Generates a combined HTML report with tabs for AU and NZ link check results."""
    try:
        au_df = pd.read_csv(au_csv_path)
        au_df['Status'] = pd.to_numeric(au_df['Status'], errors='coerce').fillna(0).astype(int)
        # Extract category hierarchy for AU
        extract_category_hierarchy(au_df, 'AU')
    except FileNotFoundError:
        print(f"Warning: AU results file not found at {au_csv_path}. AU tab will be empty.")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])
    except Exception as e:
        print(f"Error reading AU CSV {au_csv_path}: {e}")
        au_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])

    try:
        nz_df = pd.read_csv(nz_csv_path)
        nz_df['Status'] = pd.to_numeric(nz_df['Status'], errors='coerce').fillna(0).astype(int)
        # Extract category hierarchy for NZ
        extract_category_hierarchy(nz_df, 'NZ')
    except FileNotFoundError:
        print(f"Warning: NZ results file not found at {nz_csv_path}. NZ tab will be empty.")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])
    except Exception as e:
        print(f"Error reading NZ CSV {nz_csv_path}: {e}")
        nz_df = pd.DataFrame(columns=['URL', 'Status', 'Response_Time', 'Error_Message'])

    # Add region column before combining
    au_df['Region'] = 'AU'
    nz_df['Region'] = 'NZ'

    # Combine dataframes for the combined CSV download
    combined_df = pd.concat([au_df, nz_df], ignore_index=True)
    # Reorder columns to have Region first, then Timestamp (if exists), then others
    if 'Timestamp' in combined_df.columns:
        cols = ['Region', 'Timestamp'] + [col for col in combined_df.columns if col not in ['Region', 'Timestamp']]
    else:
        cols = ['Region'] + [col for col in combined_df.columns if col != 'Region']
    combined_df = combined_df[cols]
    combined_csv_path = 'combined_link_check_results.csv'
    # combined_df.to_csv(combined_csv_path, index=False) # Removed generation of combined CSV
    # print(f"✅ Combined CSV report saved to {combined_csv_path}")

    total_links_au = len(au_df[au_df['Region'] == 'AU']) # Filter by region just in case, though au_df is already AU
    broken_links_au = len(au_df[(au_df['Region'] == 'AU') & (au_df['Status'] >= 400)])
    total_links_nz = len(nz_df[nz_df['Region'] == 'NZ'])
    broken_links_nz = len(nz_df[(nz_df['Region'] == 'NZ') & (nz_df['Status'] >= 400)])

    # Create filtered dataframes for HTML tables (only errors)
    # The original au_df and nz_df are used for overall summary statistics
    au_error_df = au_df[au_df['Status'] >= 400].copy()
    nz_error_df = nz_df[nz_df['Status'] >= 400].copy()

    # Persist today's broken links to SQLite and enforce retention
    changes = {'yesterday': {'added': [], 'removed': []}, 'week': {'added': [], 'removed': []}}
    try:
        conn = _connect_db(db_path)
        _ensure_retention(conn, keep_days=60)
        # Merge for storage to avoid two passes
        merged_err_df = pd.concat([au_error_df, nz_error_df], ignore_index=True)
        print(f"Debug: Merged error dataframe has {len(merged_err_df)} rows")
        
        # Ensure required columns exist
        for col in ['Timestamp','Region','URL','Status','Response_Time','Error_Message']:
            if col not in merged_err_df.columns:
                merged_err_df[col] = ''
        
        # Add current timestamp if missing
        if 'Timestamp' not in merged_err_df.columns or merged_err_df['Timestamp'].isna().all():
            merged_err_df['Timestamp'] = datetime.now().isoformat()
        
        _store_broken_links_today(conn, merged_err_df)
        print(f"Debug: Stored {len(merged_err_df)} broken links to database")
        
        changes = _compute_changes(conn)
        print(f"Debug: Changes computed - Yesterday: {len(changes['yesterday']['added'])} added, {len(changes['yesterday']['removed'])} removed")
        print(f"Debug: Changes computed - Week: {len(changes['week']['added'])} added, {len(changes['week']['removed'])} removed")
        
        # Build a single combined CSV: Region, URL, Change, Window
        combined_rows = []
        for reg, url in changes['yesterday']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Yesterday"})
        for reg, url in changes['yesterday']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Yesterday"})
        for reg, url in changes['week']['added']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Added", "Window": "Last 7 Days"})
        for reg, url in changes['week']['removed']:
            combined_rows.append({"Region": reg, "URL": url, "Change": "Removed", "Window": "Last 7 Days"})
        
        try:
            pd.DataFrame(combined_rows, columns=["Region","URL","Change","Window"]).to_csv('changes_all.csv', index=False)
            print(f"Debug: Wrote {len(combined_rows)} changes to changes_all.csv")
        except Exception as e:
            print(f"Failed to write combined changes CSV: {e}")
            
    except Exception as e:
        print(f"Error in database operations: {e}")
        import traceback
        traceback.print_exc()
        # Initialize empty changes if database operations fail
        changes = {'yesterday': {'added': [], 'removed': []}, 'week': {'added': [], 'removed': []}}
    finally:
        try:
            conn.close()
        except Exception:
            pass

    # Generate HTML tables using the filtered error dataframes
    # Drop 'Region' for individual table view; errors='ignore' handles cases where 'Region' might not exist (e.g., empty df)
    au_table_html = generate_html_table_from_df(au_error_df.drop(columns=['Region'], errors='ignore'), 'auLinkTable')
    nz_table_html = generate_html_table_from_df(nz_error_df.drop(columns=['Region'], errors='ignore'), 'nzLinkTable')

    # Build Changes tab HTML
    def render_changes_section(title: str, items: list[tuple[str,str]], change_type: str):
        # items: list of (Region, URL)
        if not items:
            return "<p>No changes.</p>"
        
        # Create unique table ID based on title and change type
        table_id = f"changes-{change_type.lower()}-{title.lower().replace(' ', '-')}"
        table_class = f"changes-table-{change_type.lower()} display"
        
        # Add change type badge to each row
        badge_class = "added" if change_type.lower() == "added" else "removed"
        badge_text = "➕ ADDED" if change_type.lower() == "added" else "➖ REMOVED"
        
        rows = ''.join([
            f"<tr><td><span class='change-type-badge {badge_class}'>{badge_text}</span></td><td>{html.escape(reg)}</td><td><a href='{html.escape(url)}' target='_blank'>{html.escape(url)}</a></td></tr>" 
            for reg, url in items
        ])
        
        return f"""
            <table id='{table_id}' class='{table_class}' style='width:100%'>
                <thead><tr><th>Type</th><th>Region</th><th>URL</th></tr></thead>
                <tbody>{rows}</tbody>
            </table>
        """

    # Generate content for yesterday's changes
    if changes['yesterday']['has_data']:
        yesterday_content = f"""
                    <div class="changes-summary">
                        <div class="change-count added">➕ Added: {len(changes['yesterday']['added'])}</div>
                        <div class="change-count removed">➖ Removed: {len(changes['yesterday']['removed'])}</div>
                        <a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a>
                    </div>
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('yesterday-added-section')">
                            <span>Added Links ({len(changes['yesterday']['added'])})</span>
                            <span class="toggle-icon" id="yesterday-added-toggle">▼</span>
                        </div>
                        <div class="collapsible-content" id="yesterday-added-section">
                            {render_changes_section('Yesterday Added', changes['yesterday']['added'], 'added')}
                        </div>
                    </div>
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('yesterday-removed-section')">
                            <span>Removed Links ({len(changes['yesterday']['removed'])})</span>
                            <span class="toggle-icon" id="yesterday-removed-toggle">▼</span>
                        </div>
                        <div class="collapsible-content" id="yesterday-removed-section">
                            {render_changes_section('Yesterday Removed', changes['yesterday']['removed'], 'removed')}
                        </div>
                    </div>
        """
    else:
        yesterday_content = """
                    <div class="changes-summary">
                        <div style="padding: 20px; text-align: center; color: #6c757d; font-style: italic;">
                            📊 No data present to compare with yesterday's broken links.
                        </div>
                    </div>
        """
    
    # Generate content for week's changes
    if changes['week']['has_data']:
        week_content = f"""
                    <div class="changes-summary">
                        <div class="change-count added">➕ Added: {len(changes['week']['added'])}</div>
                        <div class="change-count removed">➖ Removed: {len(changes['week']['removed'])}</div>
                        <a class=\"download-tab-button\" download href=\"changes_all.csv\">Download All Changes (CSV)</a>
                    </div>
                    
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('week-added-section')">
                            <span>➕ Added Links ({len(changes['week']['added'])})</span>
                            <span class="toggle-icon" id="week-added-toggle">▼</span>
                        </div>
                        <div class="collapsible-content" id="week-added-section">
                            {render_changes_section('Added Week', changes['week']['added'], 'added')}
                        </div>
                    </div>
                    
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleSection('week-removed-section')">
                            <span>➖ Removed Links ({len(changes['week']['removed'])})</span>
                            <span class="toggle-icon" id="week-removed-toggle">▼</span>
                        </div>
                        <div class="collapsible-content" id="week-removed-section">
                            {render_changes_section('Removed Week', changes['week']['removed'], 'removed')}
                        </div>
                    </div>
        """
    else:
        week_content = """
                    <div class="changes-summary">
                        <div style="padding: 20px; text-align: center; color: #6c757d; font-style: italic;">
                            📊 No data present to compare with 7 days ago broken links.
                        </div>
                    </div>
        """

    changes_html = f"""
        <div id="Changes" class="tab-content">
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleSection('yesterday-section')">
                    <span>Changes since Yesterday</span>
                    <span class="toggle-icon" id="yesterday-toggle">▼</span>
                </div>
                <div class="collapsible-content" id="yesterday-section">
{yesterday_content}
                </div>
            </div>

            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleSection('week-section')">
                    <span>Changes vs 7 Days Ago</span>
                    <span class="toggle-icon" id="week-toggle">▼</span>
                </div>
                <div class="collapsible-content" id="week-section">
{week_content}
                </div>
            </div>
        </div>
    """

    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Broken Link Report</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
        <style>
            {STYLE_DEFINITIONS}
        </style>
    </head>
    <body>
        <button onclick="scrollToTop()" id="scrollTopBtn" title="Go to top">&#x2191;</button> <!-- Up arrow -->
        <button onclick="scrollToBottom()" id="scrollBottomBtn" title="Go to bottom">&#x2193;</button> <!-- Down arrow -->
        <header>
            <h1>Kmart Link Check Report</h1>
        </header>
        <div class="container">
        <!-- <a href="combined_link_check_results.csv" download class="download-button">Download Combined CSV</a> --> <!-- Removed combined CSV download link -->

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-link active" onclick="openTab(event, 'AU_Report')">AU</button>
                <button class="tab-link" onclick="openTab(event, 'NZ_Report')">NZ</button>
                <button class="tab-link" onclick="openTab(event, 'Changes')">Changes</button>
                <!-- Categories tab disabled -->
            </div>

            <div id="AU_Report" class="tab-content" style="display: block;">
                <div class="summary-container">
                    <span class="summary-item">🔍 Total Links Checked (AU): {total_links_au}</span>
                    <span class="summary-item">❌ Broken Links (AU): {broken_links_au}</span>
                    <span class="summary-item">✅ Valid Links (AU): {total_links_au - broken_links_au}</span>
                    <span class="summary-item"><a href="au_link_check_results.csv" download class="download-tab-button">Download AU Full CSV</a></span>
                </div>
                {au_table_html}
            </div>

            <div id="NZ_Report" class="tab-content">
                <div class="summary-container">
                    <span class="summary-item">🔍 Total Links Checked (NZ): {total_links_nz}</span>
                    <span class="summary-item">❌ Broken Links (NZ): {broken_links_nz}</span>
                    <span class="summary-item">✅ Valid Links (NZ): {total_links_nz - broken_links_nz}</span>
                    <span class="summary-item"><a href="nz_link_check_results.csv" download class="download-tab-button">Download NZ Full CSV</a></span>
                </div>
                {nz_table_html}
            </div>
            {changes_html}

            <!-- Categories tab content disabled -->
        </div>
        </div>

        <script>
            function openTab(evt, reportName) {{
                var i, tabcontent, tablinks;
                tabcontent = document.getElementsByClassName("tab-content");
                for (i = 0; i < tabcontent.length; i++) {{
                    tabcontent[i].style.display = "none";
                }}
                tablinks = document.getElementsByClassName("tab-link");
                for (i = 0; i < tablinks.length; i++) {{
                    tablinks[i].className = tablinks[i].className.replace(" active", "");
                }}
                document.getElementById(reportName).style.display = "block";
                evt.currentTarget.className += " active";
            }}

            $(document).ready(function() {{
                ['#auLinkTable', '#nzLinkTable'].forEach(function(tableId) {{
                    if (!$(tableId).length) return; // If table doesn't exist, skip

                    var table = $(tableId).DataTable({{
                        pageLength: 100,
                        orderCellsTop: true,
                        fixedHeader: true,
                        initComplete: function () {{
                            var api = this.api();
                            // Check for the correct number of filterable columns (Timestamp, URL, Status, Response_Time, Error_Message)
                            var filterHeaderCells = $(tableId + ' thead tr.filters th');
                            if (filterHeaderCells.length !== 5) {{
                                console.error('Expected 5 filterable columns for ' + tableId + ', found ' + filterHeaderCells.length + '. Skipping filter setup.');
                                return;
                            }}

                            api.columns().eq(0).each(function (colIdx) {{
                                // Get the input element for the current column's filter
                                var inputElement = $(filterHeaderCells[colIdx]).find('input');
                                
                                $(inputElement)
                                    .off('keyup change') // Remove previous event handlers to prevent duplicates
                                    .on('keyup change', function (e) {{
                                        e.stopPropagation();
                                        // Perform search, treating input as literal string (regex: false, smart: false)
                                        var searchValue = this.value;
                                        api.column(colIdx).search(searchValue, false, false).draw();
                                        
                                        // Restore cursor position if the element is still focused
                                        if (document.activeElement === this) {{
                                            var cursorPos = this.selectionStart;
                                            this.focus();
                                            this.setSelectionRange(cursorPos, cursorPos);
                                        }}
                                    }});
                            }});
                        }},
                        rowCallback: function(row, data, index){{
                             var statusCell = data[2]; // Status is now at index 2 (Timestamp, URL, Status, ...)
                             var status = parseInt(statusCell) || 0;
                             $(row).removeClass('ok error redirect');
                            if (status >= 400) {{
                                $(row).addClass('error');
                            }} else if (status >= 300) {{
                                $(row).addClass('redirect');
                            }} else if (status === 200) {{
                                $(row).addClass('ok');
                            }}
                        }}
                    }});
                }});
                
                // Initialize DataTables for changes tables
                var changesTables = [
                    '#yesterday-added-table', '#yesterday-removed-table',
                    '#week-added-table', '#week-removed-table'
                ];
                
                changesTables.forEach(function(tableId) {{
                    if (!$(tableId).length) return; // If table doesn't exist, skip
                    
                    $(tableId).DataTable({{
                        pageLength: 50,
                        orderCellsTop: true,
                        fixedHeader: true,
                        dom: 'Bfrtip',
                        buttons: [
                            'copy', 'csv', 'excel', 'pdf', 'print'
                        ],
                        order: [[2, 'asc']] // Sort by URL column
                    }});
                }});
            }});
            
            // Scroll buttons logic
            var scrollTopButton = document.getElementById("scrollTopBtn");
            var scrollBottomButton = document.getElementById("scrollBottomBtn");
            var pageBody = document.body;
            var pageDocumentElement = document.documentElement;

            window.onscroll = function() {{scrollFunction()}};

            function scrollFunction() {{
                // Show scrollTopBtn if scrolled down, hide if near the top
                if (scrollTopButton) {{
                    if (pageBody.scrollTop > 30 || pageDocumentElement.scrollTop > 30) {{
                        scrollTopButton.style.display = "block";
                    }} else {{
                        scrollTopButton.style.display = "none";
                    }}
                }}

                // Show scrollBottomBtn if not near the bottom, hide if at the bottom.
                // Also ensure it's shown if page is scrollable at all from the top
                if (scrollBottomButton) {{
                    let isPageScrollable = pageDocumentElement.scrollHeight > pageDocumentElement.clientHeight;
                    let isAtBottom = (window.innerHeight + window.scrollY) >= pageDocumentElement.offsetHeight - 30; // 30px buffer

                    if (isPageScrollable && !isAtBottom) {{
                        scrollBottomButton.style.display = "block";
                    }} else {{
                        scrollBottomButton.style.display = "none";
                    }}
                }}
            }}
            // Initial check in case the page loads scrolled or is too short to scroll
            scrollFunction();

            // Assign functions to window so inline onclick can find them
            window.scrollToTop = function() {{ 
                pageBody.scrollTop = 0; // For Safari
                pageDocumentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }};
            window.scrollToBottom = function() {{
                pageBody.scrollTop = pageDocumentElement.scrollHeight; // For Safari
                pageDocumentElement.scrollTop = pageDocumentElement.scrollHeight; // For Chrome, Firefox, IE and Opera
            }};
            
            // Toggle functionality for collapsible sections
            window.toggleSection = function(sectionId) {{
                var content = document.getElementById(sectionId);
                var toggleIcon = document.getElementById(sectionId.replace('-section', '-toggle'));
                var header = content.previousElementSibling;
                
                if (content.classList.contains('active')) {{
                    content.classList.remove('active');
                    header.classList.remove('active');
                    toggleIcon.textContent = '▼';
                    toggleIcon.classList.remove('rotated');
                }} else {{
                    content.classList.add('active');
                    header.classList.add('active');
                    toggleIcon.textContent = '▲';
                    toggleIcon.classList.add('rotated');
                }}
            }};
            
            // Category tab functionality
            window.openCategory = function(evt, categoryName) {{
                var i, categoryContent, categoryTabs;
                categoryContent = document.getElementsByClassName('category-content');
                for (i = 0; i < categoryContent.length; i++) {{
                    categoryContent[i].classList.remove('active');
                }}
                categoryTabs = document.getElementsByClassName('category-tab');
                for (i = 0; i < categoryTabs.length; i++) {{
                    categoryTabs[i].classList.remove('active');
                }}
                document.getElementById(categoryName).classList.add('active');
                evt.currentTarget.classList.add('active');
            }};
        </script>
    </body>
    </html>
    """

    with open(output_html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"✅ Combined HTML report saved to {output_html_path}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate a combined HTML report for AU and NZ link checks.')
    parser.add_argument('--au-csv', default='au_link_check_results.csv', help='Path to the AU link check results CSV file.')
    parser.add_argument('--nz-csv', default='nz_link_check_results.csv', help='Path to the NZ link check results CSV file.')
    parser.add_argument('--output-html', default='combined_report.html', help='Path to save the combined HTML report.')
    args = parser.parse_args()

    generate_combined_html_report(args.au_csv, args.nz_csv, args.output_html)
